#  Copyright 2019 Kaidan Gustave
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from typing import List, Union
from jagtag import ParseFunction, ParseBiFunction
from inspect import signature
from functools import wraps


class Method:
    """A parsing method for a JagTag parser to use.
    """

    def __init__(
        self,
        name: str,
        fn_simple: ParseFunction = None,
        fn_complex: ParseBiFunction = None,
        splitter: Union[List[str], bool] = None
    ):
        """Constructs a new :class:`Method`.

        Methods may have either a simple parse function, a complex parse function, or both, but never neither.

        Simple parse functions are of the type :class:`ParseFunction` and take a single :class:`dict` representing
        the JagTag Parser environment.

        Complex parse functions are of the type :class:`ParseBiFunction` and take two arguments. The first being similar
        to the simple parse function, a :class:`dict` representing the JagTag Parser environment, and a :class:`list`
        representing the arguments of the complex parse which occur after a ':' in the method usage.
        The way these arguments are processed into the provided list depends mostly on the specification of the
        `splitter` parameter (see parameter documentation for more details).

        Parameters
        -----------
        name:
            The name of the Method.
        fn_simple:
            The simple parse function for the Method, which takes a dict of the parser environment.
            By default, this value is None.
        fn_complex:
            The complex parse function for the Method, which takes a dict of the parser environment and a list of
            string arguments generated by the splitter. By default this value is None.
        splitter:
            Either a bool argument True or False, or a list of strings. If the value of this parameter is False, None,
            or an empty list, the complex parse function will not split the text argument provided to it. If the value
            of this parameter is True, the complex parse function will split the text argument on every pipe character
            (IE: '|'). Finally, if the value of this parameter is a list of one or more strings, the complex parse will
            split the text argument once for each element string in the order they occur via the list.
        """
        self.name = name

        # check to make sure at least one of the parse functions is not None.
        if fn_simple is None and fn_complex is None:
            raise ValueError('Either fn_simple and/or fn_complex must be defined!')

        self._fn_simple = fn_simple
        self._fn_complex = fn_complex
        if type(splitter) is bool:
            self._splitter = None if not splitter else list()
        else:
            self._splitter = None if splitter is None or len(splitter) == 0 else splitter

    def parse_simple(self, env):
        return None if self._fn_simple is None else self._fn_simple(env)

    def parse_complex(self, env, input_text: str):
        # We don't have a complex parse function to use
        if self._fn_complex is None:
            return None

        # the splitter was not specified, or was specified as false
        if self._splitter is None:
            # do not split input, provide singleton list with text input as the only element
            split_input_text = [input_text]

        # the splitter was specified as an empty list, or was specified as true
        elif len(self._splitter) == 0:
            # split on pipe characters
            split_input_text = input_text.split('|')

        # the splitter was specified as a non-empty list
        else:
            # Generate a list of inputs from elements of the splitter list of this class instance.
            #
            # EX: if self._splitter is a list containing the elements '/', '|', '\', providing the
            # input_text value 'sally/sunny|shady\sands' will result in the complex parse function
            # receiving the following list of values: ['sally', 'sunny', 'shady', 'sands'].
            split_input_text = list()
            for i in range(0, len(self._splitter)):
                index = input_text.find(self._splitter[i])
                # the split index was not found, this statement is invalid and shouldn't be processed further
                if index == -1:
                    return f'<invalid {self.name} statement>'
                split_input_text.append(input_text[0:index])
                input_text = input_text[index + len(self._splitter[i]):]
            # add the remaining content to the list
            split_input_text.append(input_text)

        # return the result of the complex parse function call
        return self._fn_complex(env, split_input_text)


def jagtag_method(name: str, simplifiable: bool = False, splitter: Union[List[str], bool] = None):
    def jagtag_decorator(func):
        sig = signature(func)
        is_complex = len(sig.parameters) == 2
        # FIXME name_to_use = name if name is not None else func.__name__

        # simplifiable is essentially the way you'd specify that the decorated function
        # can parse both simple and complex cases.
        # Typically this would be achievable via a sort of check near the start of the
        # call, for example:
        #
        # @jagtag_method(name='chat', simplifiable=True)
        # def my_parse_func(env, args):
        #     user = env['user']
        #     if args is None:
        #         return f'{user} has entered the chat!'
        #     return f'{user} said: "{args[0]}"'
        if simplifiable:
            if not is_complex:
                raise ValueError('For simplifiable to work, the function must have two parameters!')

            @wraps(func)
            def simplifiable_wrapper():
                return Method(name, lambda env: func(env, None), func, splitter)

            return simplifiable_wrapper

        @wraps(func)
        def wrapper():
            if not is_complex:
                return Method(name, func, None)
            else:
                return Method(name, None, func, splitter)

        return wrapper

    return jagtag_decorator
